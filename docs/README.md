# 泛型

## 1. 泛型的定义
泛型，即“参数化类型”。一提到参数，最熟悉的就是定义方法时有形参，然后调用此方法时传递实参。那么参数化类型怎么理解呢？顾名思义，就是将类型由原来的具体的类型参数化，类似于方法中的变量参数，此时类型也定义成参数形式（可以称之为类型形参），然后在使用/调用时传入具体的类型（类型实参）。

泛型的本质是为了参数化类型（在不创建新的类型的情况下，通过泛型指定的不同类型来控制形参具体限制的类型）。也就是说在泛型使用过程中，操作的数据类型被指定为一个参数，这种参数类型可以用在类、接口和方法中，分别被称为泛型类、泛型接口、泛型方法。

## 2. 概述
### 2.1 解决的问题
在开始介绍泛型的知识之前，先来了解一下泛型解决了什么问题，换句话说，为什么需要使用泛型。集合类是在开发过程中经常要用的类，下面是不使用泛型的代码示例。
```Java
// 定义一个List，add()可以存放Object及其子类实例
List list = new ArrayList();
list.add(123); // 合法
list.add("123"); // 合法

// 我们在编译时无法知晓list到底存放的什么数据，于是在进行强制转换时发生异常
int i = (Integer) list.get(1); // 抛出ClassCastException异常
```
上面的代码首先实例化一个`ArrayList`对象，它可以存放所有Object及其子类实例。分别`add`一个`Integer`类型对象和`String`类型对象，我们原本以为`list`中存放的全部是`Integer`类型对象，于是在使用`get()`方法获取对象后进行强制转换。从代码中可以看到，索引值为1的位置放置的`String`类型，很显然在进行强制转换时会抛出`ClassCastException`（类型转换异常）。由于这种异常只会发生在运行时，我们在开发时稍有不慎，就会直接掉到坑里，还很难排查出问题。

为什么会出现这种问题呢？

1. 集合本身无法对其存放的对象类型进行限定，可以涵盖Java中的所有类型。缺口太大，导致各种蛇、蚁、虫、鼠通通都可以进来。
2. 由于我们要使用的实际存放类型的方法，所以不可避免地要进行类型转换。小对象转大对象很容易，大对象转小对象则有很大的风险，因为在编译时，我们无从得知对象真正的类型。

泛型就是为了解决这类问题而诞生的。

## 3. 特性
在编译之后程序会采取去泛型化的措施。也就是说Java中的泛型，只在编译阶段有效。在编译过程中，正确检验泛型结果后，会将泛型的相关信息擦出，并且在对象进入和离开方法的边界处添加类型检查和类型转换的方法。也就是说，泛型信息不会进入到运行时阶段。

**对此总结成一句话：泛型类型在逻辑上看以看成是多个不同的类型，实际上都是相同的基本类型。**

```Java
List<String> stringArrayList = new ArrayList<String>();
List<Integer> integerArrayList = new ArrayList<Integer>();

Class classStringArrayList = stringArrayList.getClass();
Class classIntegerArrayList = integerArrayList.getClass();

if(classStringArrayList.equals(classIntegerArrayList)){
    Log.d("泛型测试","类型相同");
}
```

## 4. 泛型的使用
泛型有三种使用方式，分别为：泛型类、泛型接口、泛型方法。

### 4.1 泛型类
泛型类型用于类的定义中，被称为泛型类。通过泛型可以完成对一组类的操作对外开放相同的接口。最典型的就是各种容器类，如：`List`、`Set`、`Map`。

```Java
//此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型
//在实例化泛型类时，必须指定T的具体类型
public class Generic<T>{
    //key这个成员变量的类型为T,T的类型由外部指定  
    private T key;

    public Generic(T key) { //泛型构造方法形参key的类型也为T，T的类型由外部指定
        this.key = key;
    }

    public T getKey(){ //泛型方法getKey的返回值类型为T，T的类型由外部指定
        return key;
    }
}
```

定义的泛型类，就一定要传入泛型类型实参么？并不是这样，在使用泛型的时候如果传入泛型实参，则会根据传入的泛型实参做相应的限制，此时泛型才会起到本应起到的限制作用。如果不传入泛型类型实参的话，在泛型类中使用泛型的方法或成员变量定义的类型可以为任何的类型。

**注意：**
1. 泛型的类型参数只能是类类型，不能是简单类型。
2. 不能对确切的泛型类型使用`instanceof`操作。如下面的操作是非法的，编译时会出错。
    ```Java
    if(ex_num instanceof Generic<Number>){   }
    ```
