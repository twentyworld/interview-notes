# Spring IOC
---
官方定义:
> IoC is also known as dependency injection (DI). It is a process whereby objects define their dependencies, that is, the other objects they work with, only through constructor arguments, arguments to a factory method, or properties that are set on the object instance after it is constructed or returned from a factory method. The container then injects those dependencies when it creates the bean. This process is fundamentally the inverse, hence the name Inversion of Control (IoC), of the bean itself controlling the instantiation or location of its dependencies by using direct construction of classes, or a mechanism such as the Service Locator pattern.

## 1. IOC/DI
`IoC`容器：最主要是完成了完成对象的创建和依赖的管理注入等等。对象和对象关系怎么表示:可以用`xml`, `properties`文件等语义化配置文件表示。描述对象关系的文件存放在哪里:可能是`classpath`, `filesystem`或者是`URL`网络资源,` servletContext`等。




## 2. 体系结构

### 2.1 `BeanFactory`
![UML][1]

**`BeanFactory`** : 作为最顶层的一个接口类，它定义了`IOC`容器的基本功能规范。

有三个子类：
- `ListableBeanFactory`: 表示这些`Bean`是可列表的
- `HierarchicalBeanFactory`：表示的是这些`Bean`是有继承关系的，也就是每个`Bean`有可能有父`Bean`。
- `AutowireCapableBeanFactory`：定义`Bean`的自动装配规则

但是从上图中我们可以发现最终的默认实现类是 `DefaultListableBeanFactory`，他实现了所有的接口。那为何要定义这么多层次的接口呢？查阅这些接口的源码和说明发现，每个接口都有他使用的场合，它主要是为了区分在`Spring`内部在操作过程中对象的传递和转化过程中，对对象的数据访问所做的限制。

这四个接口共同定义了`Bean`的集合、`Bean`之间的关系、以及`Bean`行为。

在`BeanFactory`里只对`IOC`容器的基本行为作了定义，根本不关心你的`bean`是如何定义怎样加载的。正如我们只关心工厂里得到什么的产品对象，至于工厂是怎么生产这些对象的，这个基本的接口不关心。

```Java
public interface BeanFactory {

	Object getBean(String name) throws BeansException;
	<T> T getBean(String name, @Nullable Class<T> requiredType) throws BeansException;
	Object getBean(String name, Object... args) throws BeansException;
	<T> T getBean(Class<T> requiredType) throws BeansException;
	boolean containsBean(String name);
	boolean isSingleton(String name) throws NoSuchBeanDefinitionException;
	boolean isPrototype(String name) throws NoSuchBeanDefinitionException;
	boolean isTypeMatch(String name, ResolvableType typeToMatch) throws NoSuchBeanDefinitionException;
	boolean isTypeMatch(String name, @Nullable Class<?> typeToMatch) throws NoSuchBeanDefinitionException;

	@Nullable
	Class<?> getType(String name) throws NoSuchBeanDefinitionException;
	String[] getAliases(String name);
}
```

而要知道工厂是如何产生对象的，我们需要看具体的`IOC`容器实现，`Spring`提供了许多`IOC`容器的实现。


从接口`BeanFactory`到`HierarchicalBeanFactory`,再到`ConfigurableBeanFactory`,是条主要的`BeanFactory`设计路径。在这条接口设计路径中,`BeanFactory`接口定义了基本的`IoC`容器的规范。在这个接口定义中,包括了`getBean()`这样的`IOC`容器的基本方法(通过这个方法可以从容器中取得`Bean`)。而`HierarchicalBeanFactory`接口在继承了`BeanFactory`的基本接口之后,增加了`getParentBeanFactory`的接口功能,使`BeanFactory`具备了双亲`loC`容器的管理功能。在接下来的`ConfigurableBeanFactory`接口中,主要定义了一些对`BeanFactory`的配置功能,比如通过`setParentBeanFactory`设置双亲`loC`容器,通过`addBeanPostProcessor()`配置`Bean`后置处理器,等等。通过这些接口设计的叠加,定义了`BeanFactory`就是简单`loC`容器的基本功能。关于`BeanFactory`简单`IoC`容器的设计,我们会在后面的内容中详细介.

第二条接口设计主线是,以`ApplicationContext`应用上下文接口为核心的接口设计,这里涉及的主要接口设计有,从` BeanFactory`到`ListableBeanFactory`, 再到`ApplicationContext`, 再到我们常用的`WebApplicationContext`或者`ConfigurableApplicationContext`接口,我们常用的应用上下文基本上都是`ConfigurableApplicationContext`或者`WebApplicationContext`的实现。在这个接口体系中, `ListableBeanFactory`和`HierarchicalBeanFactory`两个接口,连接`BeanFactory`接口
定义和`ApplicationConext`应用上下文的接口定义,在`ListableBeanFactory`接口中,细化了许多`BeanFactory`的接口功能,比如定义了`getBeanDefinitionNames`接口方法;对于`HierarchicalBeanFactory`接口,我们在前文中已经提到过;对于`ApplicationContext`接口,它通过继承`Messagesource`、` Resourceloader`、 `ApplicationEventPublisher`接口，在`BeanFactory`简单`IOC`容器的基础上添加了许多高级容器的特性。

这里涉及的是主要接口关系,而具体的`IoC`容器都是在这个接口体系下实现的,比如`DefaultListableBeanFactory`,这个基本`IoC`容器的实现就是实现了`ConfigurableBeanFactory`,从而成为一个简单`IoC`容器的实现。像其他`IoC`容器,比如`XmIBeanFactory`,都是在`DefaultListableBeanFactory`的基础上做扩展,同样地`ApplicationContext`的实现也是如此

这个接口系统是以`BeanFactory`和`ApplicationContext`为核心的。而`BeanFactory`又是`loC`容器的最基本接口,在 `ApplicationContext`的设计中,一方面,可以看到它继承了`BeanFactory`接口体系中的`ListableBeanFactory`、`AutowireCapableBeanFactory`` HierarchicalBeanFactory`等`BeanFactory`的接口,具备了`BeanFactory IoC`容器的基本功能;另一方面,通过继承`MessageSource`、 `Resourceloadr`、 `ApplicationEventPublisher`这些接口, `BeanFactory`为`ApplicationContext`赋予了更高级的`IoC`容器特性。对于`ApplicationContext`而言,为了在`Web`环境中使用它,还设计了`WebApplicationContext`接口,而这个接口通过继承`ThemeSource`接口来扩充功能。





### 2.2 `BeanDefinition`
`SpringIOC`容器管理了我们定义的各种`Bean`对象及其相互的关系`，Bean`对象在`Spring`实现中是以`BeanDefinition`来描述的. 其继承体系如下

![][2]


## 3. IOC容器初始化
IoC容器的初始化包括`BeanDefinition`的`Resource`定位、载入和注册这三个基本的过程。
在这里，以`ApplciationContext`为例。

![][3]

`ApplicationContext`允许上下文嵌套，通过保持父上下文可以维持一个上下文体系。对于`bean`的查找可以在这个上下文体系中发生，首先检查当前上下文，其次是父上下文，逐级向上，这样为不同的`Spring`应用提供了一个共享的`bean`定义环境。












### 3.1 `XmlBeanFactory`的容器创建过程。
![][4]

#### `XmlBeanFactory`源码。

构造方法:
```Java
public class XmlBeanFactory extends DefaultListableBeanFactory {
	private final XmlBeanDefinitionReader reader = new XmlBeanDefinitionReader(this);

	public XmlBeanFactory(Resource resource) throws BeansException {
		this(resource, null);
	}
	public XmlBeanFactory(Resource resource, BeanFactory parentBeanFactory) throws BeansException {
		super(parentBeanFactory);
		this.reader.loadBeanDefinitions(resource);
	}
}
```


































### 3.2 `ApplicationContext()`的`IOC`容器流程。

**`ApplicationContext`提供了许多`BeanFctory`不具备的功能** ：
- 支持不同的信息源。我们看到`ApplicationContext`扩展了`MessageSource`接口,这些息源的扩展功能可以支持国际化的实现,为开发多语言版本的应用提供服务。
- 访问资源。这一特性体现在对`ResourceLoader`和`Resource`的支持上,这样我们可以不同地方得到`Bean`定义资源。这种抽象使用户程序可以灵活地定义`Bean`定义信息，尤其是从不同的IO途径得到Bean定义信息。这在接口关系上看不出来,不过一般来说,具体`ApplicationContext`都是继承了`DefaultResourceLoader`的子类
`DefaultResourceLoader`是`AbstractApplicationContext`的基类,关于`Resource`在`loC`容器中的使用,后面会有详细的讲解
- 支持应用事件。继承了接口`ApplicationEventPublisher`,从而在上下文中引入了事件机制。这些事件和`Bean`的生命周期的结合为`Bean`的管理提供了便利.
- 在`ApplicationContext`中提供的附加服务。这些服务使得基本`loC`容器的功能更丰富。因为具备了这些丰富的附加功能,使得 `ApplicationContext`与简单的`BeanFactory`相对它的使用是一种面向框架的使用风格,所以一般建议在开发应用时`ApplicationContext`作为`IoC`容器的基本形式.


我们调用`FileSystemXmlApplicationContext`：
```Java
ApplicationContext =new FileSystemXmlApplicationContext(xmlPath);
```
我们调用`FileSystemXmlApplicationContext`的构造方法。
```Java
public class FileSystemXmlApplicationContext extends AbstractXmlApplicationContext {
	public FileSystemXmlApplicationContext() {
	}

	public FileSystemXmlApplicationContext(ApplicationContext parent) {
		super(parent);
	}

	public FileSystemXmlApplicationContext(String configLocation) throws BeansException {
		this(new String[] {configLocation}, true, null);
	}


  public FileSystemXmlApplicationContext(String... configLocations) throws BeansException {
		this(configLocations, true, null);
	}

	public FileSystemXmlApplicationContext(String[] configLocations, ApplicationContext parent) throws BeansException {
		this(configLocations, true, parent);
	}

	public FileSystemXmlApplicationContext(String[] configLocations, boolean refresh) throws BeansException {
		this(configLocations, refresh, null);
	}

	public FileSystemXmlApplicationContext(String[] configLocations, boolean refresh, @Nullable ApplicationContext parent) throws BeansException {
		super(parent);
		setConfigLocations(configLocations);
		if (refresh) refresh();
	}
	protected Resource getResourceByPath(String path) {
		if (path.startsWith("/")) {
			path = path.substring(1);
		}
		return new FileSystemResource(path);
	}
}
```
他们都在最后通过调用到了：
```Java
public FileSystemXmlApplicationContext(String[] configLocations, boolean refresh, @Nullable ApplicationContext parent) throws BeansException {
	super(parent);
	setConfigLocations(configLocations);
	if (refresh) refresh();
}
protected Resource getResourceByPath(String path) {
	if (path.startsWith("/")) {
		path = path.substring(1);
	}
	return new FileSystemResource(path);
}
```
简单来说,`IoC`容器的初始化是由前面介绍的`refresh()`方法来启动的,这个方法标志`loC`容器的正式启动。具体来说,这个启动包括 `BeanDefinition`的`Resouce`定位、载入和注册三个基本过程。如果我们了解如何编程式地使用`IoC`容器,就可以清楚地看到`Resource`定位和载入过程的接口调用。在下面的内容里,我们将会详细分析这三个过程的实现在分析之前,要注意的是, `Spring`把这三个过程分开,并使用不同的模块完成,如使用相应的`Resource Loader`、 `BeanDefinitionReader`等模块,通过这样的设计方式来完成, 可以让用户更加灵活地对这三个过程进行剪裁或扩展,定义出最适合自己的oC容器的初始化过程.

- 第一个过程是`Resource`定位过程,这个`Resource`定位指的是`BeanDefinition`的资源定位,它由`Resourceloader`通过统一的`Resource`接口来完成,这个`Resource`对各种形式的`BeanDefinition`的使用都提供了统一接口,对于这些`BeanDefinition`的存在形式,相信大家都不会感到陌生。比如,在文件系统中的`Bean`定义信息可以使用 `FileSystemResource`来进行抽象,在类路径中的`Bean`定义信息可以使用前面提到的`ClassPathResource`来使用,等等,这个定位过程类似于容器寻找数据的过程,就像用水桶装水先要把水找到一样。

- 第二个过程是 `BeanDefinition`的载入,这个载入过程是把用户定义好的`Bean`表示成`loC`容器内部的数据结构,而这个容器内部的数据结构就是`BeanDefinition`,下面介绍这个数据结构的详细定义。具体来说,这个`BeanDefinition`实际上就是`POJO`对象在`loC`容器中的抽象,通过这个`BeanDefinition`定义的数据结构,使`IoC`容器能够方便地对`POJO`对象也就是`Bean`进行管理。

- 第三个过程是向`IoC`容器注册这些`BeanDefinition`的过程,这个过程是通过调用`BeanDefinitionRegistry`接口的实现来完成的。这个注册过程把载入过程中解析得到的`BeanDefinition`向`IoC`容器进行注册。通过分析,我们可以看到,在`IoC`容器内部将`BeanDefinition`注入到一个`HashMap`中去,`IoC`容器就是通过这个`HashMap`来持有这些`BeanDefinition`数据的.

值得注意的是,这里谈的是`1oC`容器初始化过程,在这个过程中,一般不包含`Bean`依赖注入的实现。在 `Spring Ioc`的设计中,`Bean`定义的载入和依赖注入是两个独立的过程,依赖注入一般发生在应用第一次通过`getBean`向容器索取`Bean`的时候。但有一个例外值得注意,在使用容器时有一个预实例化的配置,通过这个预实例化的配置(具体来说,可以通过为`Bean`定义信息中的`lazyinit`属性),用户可以对容器初始化过程作一个微小的控制,从而改变这个被设置了`lazyinit`属性的`Bean`的依赖注入过程。举例来说,如果我们对某个`Bean`设置了`lazyinit`属性,那么这个`Bean`的依赖注入在`loC`容器初始化时就预先完成了,而不需要等到整个初始化完成以后,第一次使用`getBean`时才会触发了解了`IoC`容器进行初始化的大致轮廓。



在对象的初始化过程中，调用`refresh`函数载入`beandefinition`，
通过分析`FileSystemXmlApplicationContext`的源代码可以知道，在创建`FileSystemXmlApplicationContext`容器时，构造方法做以下两项重要工作：

- 调用父类容器的构造方法`(super(parent)`方法)为容器设置好`Bean`资源加载器。
- 再调用父类`AbstractRefreshableConfigApplicationContext`的`setConfigLocations(configLocations)`方法设置`Bean`定义资源文件的定位路径。

#### 3.2.1 为容器设置`Bean`资源加载器
通过追踪`FileSystemXmlApplicationContext`的继承体系，发现`AbstractApplicationContext`中初始化`IoC`容器所做的主要源码如下：
```Java
public abstract class AbstractApplicationContext extends DefaultResourceLoader
		implements ConfigurableApplicationContext {
    //静态初始化块，在整个容器创建过程中只执行一次  
    static {
  		// Eagerly load the ContextClosedEvent class to avoid weird classloader issues
  		// on application shutdown in WebLogic 8.1. (Reported by Dustin Woods.)
  		ContextClosedEvent.class.getName();
  	}
    //AbstractApplicationContext构造方法中调用PathMatchingResourcePatternResolver的构造方法创建Spring资源加载器
  	public AbstractApplicationContext() {
  		this.resourcePatternResolver = getResourcePatternResolver();
  	}
    //FileSystemXmlApplicationContext调用父类构造方法调用的就是该方法  
  	public AbstractApplicationContext(@Nullable ApplicationContext parent) {
  		this();
  		setParent(parent);
  	}
  //获取一个Spring Source的加载器用于读入Spring Bean定义资源文件  
    protected ResourcePatternResolver getResourcePatternResolver() {
      return new PathMatchingResourcePatternResolver(this);
    }

    @Override
    public void setParent(@Nullable ApplicationContext parent) {
      this.parent = parent;
      if (parent != null) {
        Environment parentEnvironment = parent.getEnvironment();
        if (parentEnvironment instanceof ConfigurableEnvironment)
          getEnvironment().merge((ConfigurableEnvironment) parentEnvironment);
      }
    }
}
```

#### 3.2.2 设置`Bean`定义资源文件的定位路径
在设置容器的资源加载器之后，接下来`FileSystemXmlApplicationContet`执行`setConfigLocations`方法通过调用其父类`AbstractRefreshableConfigApplicationContext`的方法进行对`Bean`定义资源文件的定位，该方法的源码如下：
```Java
public void setConfigLocations(@Nullable String... locations) {
  if (locations != null) {
    Assert.noNullElements(locations, "Config locations must not be null");
    this.configLocations = new String[locations.length];
    for (int i = 0; i < locations.length; i++) {
      this.configLocations[i] = resolvePath(locations[i]).trim();
    }
  }
  else {
    this.configLocations = null;
  }
}

  protected String resolvePath(String path) {
    return getEnvironment().resolveRequiredPlaceholders(path);
  }

  public ConfigurableEnvironment getEnvironment() {
    if (this.environment == null) {
      this.environment = createEnvironment();
    }
    return this.environment;
  }
  protected ConfigurableEnvironment createEnvironment() {
    return new StandardEnvironment();
  }

}
```
至此，`Spring IoC`容器在初始化时将配置的`Bean`定义资源文件定位为`Spring`封装的`Resource`。

#### 3.2.3 `refresh`函数载入`Bean`定义过程

在完成对代表`BeanDefinition`的`Resource`定位的分析后,下面来了解整个`BeanDefinition`信息的载入过程。对`loC`容器来说,这个载入过程,相当于把定义的`BeanDefinition`在`loC`器中转化成一个`Spring`内部表示的数据结构的过程。`IoC`容器对`Bean`的管理和依赖注入功能的实现,是通过对其持有的`BeanDefinition`进行各种相关操作来完成的。这些`BeanDefinition`数据在`IoC`容器中通过一个`HashMap`来保持和维护。当然这只是一种比较简单的维护方式如果需要提高`loC`容器的性能和容量,完全可以自己做一些扩展。

下面,从`DefaultListableBeanFactory`的设计入手,看看`IoC`容器是怎样完成`BeanDefinition`载入的。在开始分析之前,先回到`IoC`容器的初始化入口,也就是看`refresh`方法。这个方法的最初是在`FileSystemXmlApplicationContext`的构造函数中被调用的它的调用标志着容器初始化的开始,这些初始化对象就是`BeanDefinition`数据初始化入口。

早前放的图可知，这里面的继承顺序：
`AbstractApplicationContext` <- `AbstractRefreshableApplicationContext` <- `AbstractRefreshableConfigApplicationContext`
   <- `AbstractXmlApplicationContext` <- `FileSystemXmlApplicationContext`
```Java
public void refresh() throws BeansException, IllegalStateException {
  synchronized (this.startupShutdownMonitor) {
    // Prepare this context for refreshing.
    prepareRefresh();

    // Tell the subclass to refresh the internal bean factory.
    ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();

    // Prepare the bean factory for use in this context.
    prepareBeanFactory(beanFactory);

    try {
      // Allows post-processing of the bean factory in context subclasses.
      postProcessBeanFactory(beanFactory);
      // Invoke factory processors registered as beans in the context.
      invokeBeanFactoryPostProcessors(beanFactory);
      // Register bean processors that intercept bean creation.
      registerBeanPostProcessors(beanFactory);
      // Initialize message source for this context.
      initMessageSource();
      // Initialize event multicaster for this context.
      initApplicationEventMulticaster();
      // Initialize other special beans in specific context subclasses.
      onRefresh();
      // Check for listener beans and register them.
      registerListeners();
      // Instantiate all remaining (non-lazy-init) singletons.
      finishBeanFactoryInitialization(beanFactory);
      // Last step: publish corresponding event.
      finishRefresh();
    }
    catch (BeansException ex) {
      if (logger.isWarnEnabled())
        logger.warn("Exception encountered during context initialization - "
          - "cancelling refresh attempt: " + ex);
      // Destroy already created singletons to avoid dangling resources.
      destroyBeans();
      // Reset 'active' flag.
      cancelRefresh(ex);
      // Propagate exception to caller.
      throw ex;
    }
    finally {
      // Reset common introspection caches in Spring's core, since we
      // might not ever need metadata for singleton beans anymore...
      resetCommonCaches();
    }
  }
}

protected void prepareRefresh() {
  this.startupDate = System.currentTimeMillis();
  this.closed.set(false);
  this.active.set(true);
  if (logger.isInfoEnabled())logger.info("Refreshing " + this);

  // Initialize any placeholder property sources in the context environment
  initPropertySources();
  // Validate that all properties marked as required are resolvable
  // see ConfigurablePropertyResolver#setRequiredProperties
  getEnvironment().validateRequiredProperties();
  // Allow for the collection of early ApplicationEvents,
  // to be published once the multicaster is available...
  this.earlyApplicationEvents = new LinkedHashSet<>();
}
```
`Spring IoC`容器对`Bean`定义资源的载入是从`refresh()`函数开始的，`refresh()`是一个模板方法，`refresh()`方法的作用是：在创建`IoC`容器前，如果已经有容器存在，则需要把已有的容器销毁和关闭，以保证在`refresh`之后使用的是新建立起来的`IoC`容器。`refresh`的作用类似于对`IoC`容器的重启，再新建立好的容器中对容器进行初始化，对`Bean`定义资源进行载入。

`refresh()`方法主要为`IoC`容器`Bean`的生命周期管理提供条件，`Spring IoC`容器载入`Bean`定义资源文件从其子类容器的`refreshBeanFactory()`方法启动，所以整个`refresh()`中`ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();`这句以后代码的都是注册容器的信息源和生命周期事件，载入过程就是从这句代码启动。

###### 3.2.3.1 `obtainFreshBeanFactory()`方法 刷新容器
**AbstractApplicationContext** 中实现。
```Java
//Tell the subclass to refresh the internal bean factory.
protected ConfigurableListableBeanFactory obtainFreshBeanFactory() {
  //这里使用了委派设计模式，父类定义了抽象的refreshBeanFactory()方法，具体实现调用子类容器的refreshBeanFactory()方法
  refreshBeanFactory();
  ConfigurableListableBeanFactory beanFactory = getBeanFactory();
  if (logger.isDebugEnabled()) {
    logger.debug("Bean factory for " + getDisplayName() + ": " + beanFactory);
  }
  return beanFactory;
}
```

在 **AbstractRefreshableApplicationContext** 中有refreshBeanFactory().
其中有关闭原来的容器，重建容器。
```Java
/**
 * This implementation performs an actual refresh of this context's underlying
 * bean factory, shutting down the previous bean factory (if any) and
 * initializing a fresh bean factory for the next phase of the context's lifecycle.
 */
@Override
protected final void refreshBeanFactory() throws BeansException {
  if (hasBeanFactory()) {
    //Template method for destroying all beans that this context manages.
    destroyBeans();
    closeBeanFactory();
  }
  try {
    DefaultListableBeanFactory beanFactory = createBeanFactory();
    beanFactory.setSerializationId(getId());
    customizeBeanFactory(beanFactory);
    loadBeanDefinitions(beanFactory);
    synchronized (this.beanFactoryMonitor) {
      this.beanFactory = beanFactory;
    }
  }
  catch (IOException ex) {
    throw new ApplicationContextException("I/O error parsing bean definition source for " + getDisplayName(), ex);
  }
}

@Override
protected final void closeBeanFactory() {
  synchronized (this.beanFactoryMonitor) {
    if (this.beanFactory != null)
      this.beanFactory.setSerializationId(null);
      this.beanFactory = null;
  }
}
protected DefaultListableBeanFactory createBeanFactory() {
  return new DefaultListableBeanFactory(getInternalParentBeanFactory());
}
protected void customizeBeanFactory(DefaultListableBeanFactory beanFactory) {
  if (this.allowBeanDefinitionOverriding != null) {
    beanFactory.setAllowBeanDefinitionOverriding(this.allowBeanDefinitionOverriding);
  }
  if (this.allowCircularReferences != null) {
    beanFactory.setAllowCircularReferences(this.allowCircularReferences);
  }
}
```

在AbstractXmlApplicationContext中调用loadBeanDefinitions()。加载bean。
```Java
//Loads the bean definitions via an XmlBeanDefinitionReader.
@Override
protected void loadBeanDefinitions(DefaultListableBeanFactory beanFactory) throws BeansException, IOException {
  // Create a new XmlBeanDefinitionReader for the given BeanFactory.
  XmlBeanDefinitionReader beanDefinitionReader = new XmlBeanDefinitionReader(beanFactory);

  // Configure the bean definition reader with this context's
  // resource loading environment.
  beanDefinitionReader.setEnvironment(this.getEnvironment());

  //祖先父类AbstractApplicationContext继承DefaultResourceLoader，因此，容器本身也是一个资源加载器  
  beanDefinitionReader.setResourceLoader(this);
   //为Bean读取器设置SAX xml解析器
  beanDefinitionReader.setEntityResolver(new ResourceEntityResolver(this));

  // Allow a subclass to provide custom initialization of the reader,
  // then proceed with actually loading the bean definitions.
  initBeanDefinitionReader(beanDefinitionReader);
  //Bean读取器真正实现加载的方法  
  loadBeanDefinitions(beanDefinitionReader);
}

//Load the bean definitions with the given XmlBeanDefinitionReader.
protected void loadBeanDefinitions(XmlBeanDefinitionReader reader) throws BeansException, IOException {
  Resource[] configResources = getConfigResources();
  if (configResources != null) {
    reader.loadBeanDefinitions(configResources);
  }
  //如果子类中获取的Bean定义资源定位为空，则获取FileSystemXmlApplicationContext构造方法中setConfigLocations方法设置的资源
  String[] configLocations = getConfigLocations();
  if (configLocations != null) {
    reader.loadBeanDefinitions(configLocations);
  }
}

//这里又使用了一个委托模式，调用子类的获取Bean定义资源定位的方法。
//该方法在ClassPathXmlApplicationContext中进行实现，的FileSystemXmlApplicationContext没有使用该方法。
@Nullable
protected Resource[] getConfigResources() {
  return null;
}

```
这里面调用了`XmlBeanDefinitionReader..loadBeanDefinitions(configLocations)`;由这里，引入了 `BeanDefinition`读取`Bean`定义资源。

通过以上对实现原理的分析,我们可以看到,在初始化`FileSystmXmlApplicationContext`的过程中是通过调用`IoC`容器的`Refresh`来启动整个 `BeanDefinition`的载入过程的,这个初始化是通过定义的`XmlBeanDefinitionReader`来完成的。同时,我们也知道实际使用的`loC`容器是
`DefultListableBeanFactory`,具体的`Resource`载入在`XmlBeanDefinitionReader`读入`BeanDefinition`时实现。因为`Spring`可以对应不同形式的`BeanDefinition`。由于这里使用的是`XML`方式的定义,所以需要使用 `XmlBeanDefinitionReader`。如果使用了其他的`BeanDefinition`方式,就需要使用其他种类的`BeanDefinitionReader`来完成数据的载入工作。
在 `XmlBeanDefinitionReader`的实现中可以看到,是在`reader.loadBeanDefinitions`中开始进行`BeanDefinition`的载入的,而这时 `XmlBeanDefinitionReader`的父类`AbstractBeanDefinitionReader`已经为`BeanDefinition`的载入做好了准备.


#### 3.2.4 `BeanDefinition` 读取`Bean`定义资源

##### 3.2.4.1 `XmlBeanDefinitionReader`读取文件。

![][5]

在抽象类`AbstractBeanDefinitionReader`中定义了
`loadBeanDefinitions(String... locations)` -> `loadBeanDefinitions(String location)` ->
  `loadBeanDefinitions(String location, @Nullable Set<Resource> actualResources)` -> `loadBeanDefinitions(resources)`
   -> `loadBeanDefinitions(resource)` -> `loadBeanDefinitions(new EncodedResource(resource))` -> `doLoadBeanDefinitions(inputSource, encodedResource.getResource())`的路径，找到了文件的路径。

```Java
public abstract class AbstractBeanDefinitionReader implements EnvironmentCapable, BeanDefinitionReader {

  public int loadBeanDefinitions(String... locations) throws BeanDefinitionStoreException {
		Assert.notNull(locations, "Location array must not be null");
		int counter = 0;
		for (String location : locations) {
			counter += loadBeanDefinitions(location);
		}
		return counter;
	}

  public int loadBeanDefinitions(String location) throws BeanDefinitionStoreException {
		return loadBeanDefinitions(location, null);
	}
  public int loadBeanDefinitions(String location, @Nullable Set<Resource> actualResources) throws BeanDefinitionStoreException {
		ResourceLoader resourceLoader = getResourceLoader();
		if (resourceLoader == null) {
			throw new BeanDefinitionStoreException(
					"Cannot import bean definitions from location [" + location + "]: no ResourceLoader available");
		}

		if (resourceLoader instanceof ResourcePatternResolver) {
			// Resource pattern matching available.
			try {
				Resource[] resources = ((ResourcePatternResolver) resourceLoader).getResources(location);
				int loadCount = loadBeanDefinitions(resources);
				if (actualResources != null) {
					for (Resource resource : resources) {
						actualResources.add(resource);
					}
				}
				if (logger.isDebugEnabled()) {
					logger.debug("Loaded " + loadCount + " bean definitions from location pattern [" + location + "]");
				}
				return loadCount;
			}
			catch (IOException ex) {
				throw new BeanDefinitionStoreException(
						"Could not resolve bean definition resource pattern [" + location + "]", ex);
			}
		}
		else {
			// Can only load single resources by absolute URL.
			Resource resource = resourceLoader.getResource(location);
			int loadCount = loadBeanDefinitions(resource);
			if (actualResources != null) {
				actualResources.add(resource);
			}
			if (logger.isDebugEnabled()) {
				logger.debug("Loaded " + loadCount + " bean definitions from location [" + location + "]");
			}
			return loadCount;
		}
	}

}
```

##### 3.2.4.2 读取资源转换为`Document`

这里做了两件事情，第一解析`xml`文件，同时把`bean`注册到容器中。
 `XmlBeanDefinitionReader`类中的`doLoadBeanDefinitions`方法是从特定`XML`文件中实际载入`Bean`定义资源的方法，该方法在载入`Bean`定义资源之后将其转换为`Document`对象，接下来调用`registerBeanDefinitions`启动`Spring IoC`容器对`Bean`定义的解析过程.

```Java
public class XmlBeanDefinitionReader extends AbstractBeanDefinitionReader {
    protected int doLoadBeanDefinitions(InputSource inputSource, Resource resource)
        throws BeanDefinitionStoreException {
      try {
        Document doc = doLoadDocument(inputSource, resource);
        return registerBeanDefinitions(doc, resource);
      }
      catch (Exception ex) {
        ...
      }
    }

    protected Document doLoadDocument(InputSource inputSource, Resource resource) throws Exception {
  		return this.documentLoader.loadDocument(inputSource, getEntityResolver(), this.errorHandler,
  				getValidationModeForResource(resource), isNamespaceAware());
  	}
}
```

##### 3.2.4.3 DocumentLoader解析xml文件。
这阶段，是由`DocumentLoader`的实现类`DefaultDocumentLoader`具体实现。

``` Java

public class DefaultDocumentLoader implements DocumentLoader {
  //使用标准的JAXP将载入的Bean定义资源转换成document对象  
	public Document loadDocument(InputSource inputSource, EntityResolver entityResolver,
			ErrorHandler errorHandler, int validationMode, boolean namespaceAware) throws Exception {

//创建文件解析器工厂  
		DocumentBuilderFactory factory = createDocumentBuilderFactory(validationMode, namespaceAware);
		if (logger.isDebugEnabled()) {
			logger.debug("Using JAXP provider [" + factory.getClass().getName() + "]");
		}
    //创建文档解析器  
		DocumentBuilder builder = createDocumentBuilder(factory, entityResolver, errorHandler);
    //解析Spring的Bean定义资源  
		return builder.parse(inputSource);
	}

  protected DocumentBuilderFactory createDocumentBuilderFactory(int validationMode, boolean namespaceAware)
			throws ParserConfigurationException {
//创建文档解析工厂  
		DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
		factory.setNamespaceAware(namespaceAware);
      //设置解析XML的校验  
		if (validationMode ! = XmlValidationModeDetector.VALIDATION_NONE) {
			factory.setValidating(true);
			if (validationMode == XmlValidationModeDetector.VALIDATION_XSD) {
				// Enforce namespace aware for XSD...
				factory.setNamespaceAware(true);
				try {
					factory.setAttribute(SCHEMA_LANGUAGE_ATTRIBUTE, XSD_SCHEMA_LANGUAGE);
				}
				catch (IllegalArgumentException ex) {
					ParserConfigurationException pcex = new ParserConfigurationException(
							"Unable to validate using XSD: Your JAXP provider [" + factory +
							"] does not support XML Schema. Are you running on Java 1.4 with Apache Crimson? " +
							"Upgrade to Apache Xerces (or Java 1.5) for full XSD support.");
					pcex.initCause(ex);
					throw pcex;
				}
			}
		}
	}
}

```


##### 3.2.4.4 `XmlBeanDefinitionReader`解析载入的`Bean`定义资源文件
`Spring`的`BeanDefinion`是怎样按照`Spring`的`Bean`语义要求进行解析并转化为容器内部数据结构的,这个过程是在 `registerBeanDefinitions(doc, resource)`中完成的。具体的过程是由`BeanDefinitionDocumentReader`来完成的,这个`registerBeanDefinition`还对载入的`Bean`的数量进行了统计。

`BeanDefinition`的载入分成两部分,首先通过调用`XML`的解析器得到`document`对象,但这些`documen`对象并没有按照`Spring`的`Bean`规则进行解析。在完成通用的`XM`L解析以后,才是照`Spring`的`Bean`规则进行解析的地方,这个按照`Spring`的`Bean`规则进行解析的过程是在`documentReader`中实现的。这里使用的`documentReader`是默认设置好的`DefaultBeanDefinitionDocumentReader`。这个`DefaultBeanDefinitionDocumentReader`的创建是在后面的方法中完成的,然后再完成`BeanDefinition`的处理,处理的结果由`BeanDefinitionHolder`对象来持有这个`BeanDefinitionHolder`除了持有`BeanDefinition`对象外,还持有其他与`BeanDefinition`的使用关的信息,比如`Bean`的名字、别名集合等。这个`BeanDefinitionHolder`的生成是通过对`Document`文档树的内容进行解析来完成的,可以看到这个解析过程是由`BeanDefinitionParserDelegate`实现(具体在`processBeanDefinition`方法中实现)的,同时这个解析是与`Spring`对`BeanDefinition`的配置规则紧密相关的.

```Java
public class XmlBeanDefinitionReader extends AbstractBeanDefinitionReader {
    public int registerBeanDefinitions(Document doc, Resource resource) throws BeanDefinitionStoreException {
      BeanDefinitionDocumentReader documentReader = createBeanDefinitionDocumentReader();
      int countBefore = getRegistry().getBeanDefinitionCount();
      documentReader.registerBeanDefinitions(doc, createReaderContext(resource));
      return getRegistry().getBeanDefinitionCount() - countBefore;
    }
    protected BeanDefinitionDocumentReader createBeanDefinitionDocumentReader() {
      return BeanDefinitionDocumentReader.class.cast(BeanUtils.instantiateClass(this.documentReaderClass));
    }
    private Class<?> documentReaderClass = DefaultBeanDefinitionDocumentReader.class;
}
```
类`XmlBeanDefinitionReader`中的`registerBeanDefinitions`方法调用了`DefaultBeanDefinitionDocumentReader`中的方法 `doRegisterBeanDefinitions(Element root)`对`documnet`对象进行解析：


具体的`SpringBeanDefinition`的解析是在`BeanDefinitionParserDelegate`中完成的。这个类里包含了对各种`SpringBean`定义规则的处理,感兴趣的读者可以仔细研究。比如我们最熟悉的对`Bean`元素的处理是怎样完成的,也就是怎样处理在`XML`定义文件中出现的`<bean><bean>`这个最常见的元素信息。在这里会看到对那些熟悉的`BeanDefinition`定义的处理,比如`id、name、aliase`等属性元素。把这些元素的值从`XML`文件相应的元素的属性中读取出来以后,设置到生成的`BeanDefinitionHolder`中去。这些属性的解析还是比较简单的对于其他元素配置的解析,比如各种`Bean`的属性配置,通过一个较为复杂的解析过程,这个过程是由`parseBeanDefinitionElement`来完成的。解析完成以后,会把解析结果放到`BeanDefinition`对象中并设置到`BeanDefinitionHolder`中去.

```Java
public class DefaultBeanDefinitionDocumentReader implements BeanDefinitionDocumentReader {


  public void registerBeanDefinitions(Document doc, XmlReaderContext readerContext) {
    //获得XML描述符
    this.readerContext = readerContext;
    logger.debug("Loading bean definitions");
    //获得Document的根元素  
    Element root = doc.getDocumentElement();

    doRegisterBeanDefinitions(root);
  }
  protected void doRegisterBeanDefinitions(Element root) {
		// Any nested <beans> elements will cause recursion in this method. In
		// order to propagate and preserve <beans> default-* attributes correctly,
		// keep track of the current (parent) delegate, which may be null. Create
		// the new (child) delegate with a reference to the parent for fallback purposes,
		// then ultimately reset this.delegate back to its original (parent) reference.
		// this behavior emulates a stack of delegates without actually necessitating one.

		BeanDefinitionParserDelegate parent = this.delegate;
		this.delegate = createDelegate(getReaderContext(), root, parent);

		if (this.delegate.isDefaultNamespace(root)) {
			String profileSpec = root.getAttribute(PROFILE_ATTRIBUTE);
			if (StringUtils.hasText(profileSpec)) {
				String[] specifiedProfiles = StringUtils.tokenizeToStringArray(
						profileSpec, BeanDefinitionParserDelegate.MULTI_VALUE_ATTRIBUTE_DELIMITERS);
				if (!getReaderContext().getEnvironment().acceptsProfiles(specifiedProfiles)) {
					if (logger.isInfoEnabled()) {
						logger.info("Skipped XML bean definition file due to specified profiles [" + profileSpec +
								"] not matching: " + getReaderContext().getResource());
					}
					return;
				}
			}
		}
//在解析Bean定义之前，进行自定义的解析，增强解析过程的可扩展性  
		preProcessXml(root);
//从Document的根元素开始进行Bean定义的Document对象  
		parseBeanDefinitions(root, this.delegate);
//在解析Bean定义之后，进行自定义的解析，增加解析过程的可扩展性      
		postProcessXml(root);

		this.delegate = parent;
	}
  //使用Spring的Bean规则从Document的根元素开始进行Bean定义的Document对象  
  protected void parseBeanDefinitions(Element root, BeanDefinitionParserDelegate delegate) {
  		if (delegate.isDefaultNamespace(root)) {
  			NodeList nl = root.getChildNodes();
  			for (int i = 0; i < nl.getLength(); i++) {
  				Node node = nl.item(i);
  				if (node instanceof Element) {
  					Element ele = (Element) node;
  					if (delegate.isDefaultNamespace(ele)) {
  						parseDefaultElement(ele, delegate);
  					}
  					else {
  						delegate.parseCustomElement(ele);
  					}
  				}
  			}
  		}
  		else {
  			delegate.parseCustomElement(root);
  		}
  	}
//使用Spring的Bean规则解析Document元素节点  
  	private void parseDefaultElement(Element ele, BeanDefinitionParserDelegate delegate) {
  		if (delegate.nodeNameEquals(ele, IMPORT_ELEMENT)) {
  			importBeanDefinitionResource(ele);
  		}
  		else if (delegate.nodeNameEquals(ele, ALIAS_ELEMENT)) {
  			processAliasRegistration(ele);
  		}
  		else if (delegate.nodeNameEquals(ele, BEAN_ELEMENT)) {
  			processBeanDefinition(ele, delegate);
  		}
  		else if (delegate.nodeNameEquals(ele, NESTED_BEANS_ELEMENT)) {
  			// recurse
  			doRegisterBeanDefinitions(ele);
  		}
  	}

  	/**
  	 * Parse an "import" element and load the bean definitions
  	 * from the given resource into the bean factory.
  	 */
  	protected void importBeanDefinitionResource(Element ele) {
  		String location = ele.getAttribute(RESOURCE_ATTRIBUTE);
  		if (!StringUtils.hasText(location)) {
  			getReaderContext().error("Resource location must not be empty", ele);
  			return;
  		}

  		// Resolve system properties: e.g. "${user.dir}"
  		location = getReaderContext().getEnvironment().resolveRequiredPlaceholders(location);

  		Set<Resource> actualResources = new LinkedHashSet<Resource>(4);

  		// Discover whether the location is an absolute or relative URI
  		boolean absoluteLocation = false;
  		try {
  			absoluteLocation = ResourcePatternUtils.isUrl(location) || ResourceUtils.toURI(location).isAbsolute();
  		}
  		catch (URISyntaxException ex) {
  			// cannot convert to an URI, considering the location relative
  			// unless it is the well-known Spring prefix "classpath*:"
  		}

  		// Absolute or relative?
  		if (absoluteLocation) {
  			try {
  				int importCount = getReaderContext().getReader().loadBeanDefinitions(location, actualResources);
  				if (logger.isDebugEnabled()) {
  					logger.debug("Imported " + importCount + " bean definitions from URL location [" + location + "]");
  				}
  			}
  			catch (BeanDefinitionStoreException ex) {
  				getReaderContext().error(
  						"Failed to import bean definitions from URL location [" + location + "]", ele, ex);
  			}
  		}
  		else {
  			// No URL -> considering resource location as relative to the current file.
  			try {
  				int importCount;
  				Resource relativeResource = getReaderContext().getResource().createRelative(location);
  				if (relativeResource.exists()) {
  					importCount = getReaderContext().getReader().loadBeanDefinitions(relativeResource);
  					actualResources.add(relativeResource);
  				}
  				else {
  					String baseLocation = getReaderContext().getResource().getURL().toString();
  					importCount = getReaderContext().getReader().loadBeanDefinitions(
  							StringUtils.applyRelativePath(baseLocation, location), actualResources);
  				}
  				if (logger.isDebugEnabled()) {
  					logger.debug("Imported " + importCount + " bean definitions from relative location [" + location + "]");
  				}
  			}
  			catch (IOException ex) {
  				getReaderContext().error("Failed to resolve current resource location", ele, ex);
  			}
  			catch (BeanDefinitionStoreException ex) {
  				getReaderContext().error("Failed to import bean definitions from relative location [" + location + "]",
  						ele, ex);
  			}
  		}
  		Resource[] actResArray = actualResources.toArray(new Resource[actualResources.size()]);
  		getReaderContext().fireImportProcessed(location, actResArray, extractSource(ele));
  	}

  	/**
  	 * Process the given alias element, registering the alias with the registry.
  	 */
  	protected void processAliasRegistration(Element ele) {
      ...
  	}

  	protected void processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate) {
  		BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);
  		if (bdHolder != null) {
  			bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);
  			try {
  				// Register the final decorated instance.
  				BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());
  			}
  			catch (BeanDefinitionStoreException ex) {
  				getReaderContext().error("Failed to register bean definition with name '" +
  						bdHolder.getBeanName() + "'", ele, ex);
  			}
  			// Send registration event.
  			getReaderContext().fireComponentRegistered(new BeanComponentDefinition(bdHolder));
  		}
  	}

}
```

通过以上代码，可以看出：
通过上述`Spring IoC`容器对载入的`Bean`定义`Document`解析可以看出，我们使用`Spring`时，在`Spring`配置文件中可以使用`<Import>`元素来导入`IoC`容器所需要的其他资源，`Spring IoC`容器在解析时会首先将指定导入的资源加载进容器中。使用`<Ailas>`别名时，`Spring IoC`容器首先将别名元素所定义的别名注册到容器中。
对于既不是`<Import>`元素，又不是`<Alias>`元素的元素，即`Spring`配置文件中普通的`<Bean>`元素的解析由`BeanDefinitionParserDelegate`类的`parseBeanDefinitionElement`方法来实现。

##### 3.2.4.5 BeanDefinitionParserDelegate解析Bean定义资源文件中的<Bean>元素

```Java
/**
 * Parses the supplied {@code <bean>} element. May return {@code null}
 * if there were errors during parse. Errors are reported to the
 * {@link org.springframework.beans.factory.parsing.ProblemReporter}.
 */
public BeanDefinitionHolder parseBeanDefinitionElement(Element ele) {
  return parseBeanDefinitionElement(ele, null);
}
public BeanDefinitionHolder parseBeanDefinitionElement(Element ele, BeanDefinition containingBean) {
  String id = ele.getAttribute(ID_ATTRIBUTE);
  String nameAttr = ele.getAttribute(NAME_ATTRIBUTE);

  List<String> aliases = new ArrayList<String>();
  if (StringUtils.hasLength(nameAttr)) {
    String[] nameArr = StringUtils.tokenizeToStringArray(nameAttr, MULTI_VALUE_ATTRIBUTE_DELIMITERS);
    aliases.addAll(Arrays.asList(nameArr));
  }

  String beanName = id;
  if (!StringUtils.hasText(beanName) && !aliases.isEmpty()) {
    beanName = aliases.remove(0);
    if (logger.isDebugEnabled()) {
      logger.debug("No XML 'id' specified - using '" + beanName +
          "' as bean name and " + aliases + " as aliases");
    }
  }

  if (containingBean == null) {
    checkNameUniqueness(beanName, aliases, ele);
  }

  AbstractBeanDefinition beanDefinition = parseBeanDefinitionElement(ele, beanName, containingBean);
  if (beanDefinition != null) {
    if (!StringUtils.hasText(beanName)) {
      try {
        if (containingBean != null) {
          beanName = BeanDefinitionReaderUtils.generateBeanName(
              beanDefinition, this.readerContext.getRegistry(), true);
        }
        else {
          beanName = this.readerContext.generateBeanName(beanDefinition);
          // Register an alias for the plain bean class name, if still possible,
          // if the generator returned the class name plus a suffix.
          // This is expected for Spring 1.2/2.0 backwards compatibility.
          String beanClassName = beanDefinition.getBeanClassName();
          if (beanClassName != null &&
              beanName.startsWith(beanClassName) && beanName.length() > beanClassName.length() &&
              !this.readerContext.getRegistry().isBeanNameInUse(beanClassName)) {
            aliases.add(beanClassName);
          }
        }
        if (logger.isDebugEnabled()) {
          logger.debug("Neither XML 'id' nor 'name' specified - " +
              "using generated bean name [" + beanName + "]");
        }
      }
      catch (Exception ex) {
        error(ex.getMessage(), ele);
        return null;
      }
    }
    String[] aliasesArray = StringUtils.toStringArray(aliases);
    return new BeanDefinitionHolder(beanDefinition, beanName, aliasesArray);
  }

  return null;
}
public AbstractBeanDefinition parseBeanDefinitionElement(
    Element ele, String beanName, BeanDefinition containingBean) {

  this.parseState.push(new BeanEntry(beanName));

  String className = null;
  if (ele.hasAttribute(CLASS_ATTRIBUTE)) {
    className = ele.getAttribute(CLASS_ATTRIBUTE).trim();
  }

  try {
    String parent = null;
    if (ele.hasAttribute(PARENT_ATTRIBUTE)) {
      parent = ele.getAttribute(PARENT_ATTRIBUTE);
    }
    //根据<Bean>元素配置的class名称和parent属性值创建BeanDefinition  
    //为载入Bean定义信息做准备  
    AbstractBeanDefinition bd = createBeanDefinition(className, parent);  
    //对当前的<Bean>元素中配置的一些属性进行解析和设置，如配置的单态(singleton)属性等  
    parseBeanDefinitionAttributes(ele, beanName, containingBean, bd);  
    //为<Bean>元素解析的Bean设置description信息
    bd.setDescription(DomUtils.getChildElementValueByTagName(ele, DESCRIPTION_ELEMENT));  

    //对<Bean>元素的meta(元信息)属性解析  
    parseMetaElements(ele, bd);  
    //对<Bean>元素的lookup-method属性解析  
    parseLookupOverrideSubElements(ele, bd.getMethodOverrides());  
    //对<Bean>元素的replaced-method属性解析  
    parseReplacedMethodSubElements(ele, bd.getMethodOverrides());  
    //解析<Bean>元素的构造方法设置  

    parseConstructorArgElements(ele, bd);  
    //解析<Bean>元素的<property>设置  
    parsePropertyElements(ele, bd);  
    //解析<Bean>元素的qualifier属性  
    parseQualifierElements(ele, bd);  
    //为当前解析的Bean设置所需的资源和依赖对象  
    bd.setResource(this.readerContext.getResource());  
    bd.setSource(extractSource(ele));

    return bd;
  }
  catch (ClassNotFoundException ex) {
    error("Bean class [" + className + "] not found", ele, ex);
  }
  catch (NoClassDefFoundError err) {
    error("Class that bean class [" + className + "] depends on not found", ele, err);
  }
  catch (Throwable ex) {
    error("Unexpected failure during bean definition parsing", ele, ex);
  }
  finally {
    this.parseState.pop();
  }

  return null;
}

```
只要使用过Spring，对Spring配置文件比较熟悉的人，通过对上述源码的分析，就会明白我们在Spring配置文件中<Bean>元素的中配置的属性就是通过该方法解析和设置到Bean中去的。

注意：在解析<Bean>元素过程中没有创建和实例化Bean对象，只是创建了Bean对象的定义类BeanDefinition，将<Bean>元素中的配置信息设置到BeanDefinition中作为记录，当依赖注入时才使用这些记录信息创建和实例化具体的Bean对象。

##### 3.2.4.6 BeanDefinitionParserDelegate解析<property>元素
```Java
//解析<Bean>元素中的<property>子元素  
   public void parsePropertyElements(Element beanEle, BeanDefinition bd) {  
       //获取<Bean>元素中所有的子元素  
       NodeList nl = beanEle.getChildNodes();  
       for (int i = 0; i < nl.getLength(); i++) {  
           Node node = nl.item(i);  
           //如果子元素是<property>子元素，则调用解析<property>子元素方法解析  
           if (isCandidateElement(node) && nodeNameEquals(node, PROPERTY_ELEMENT)) {  
               parsePropertyElement((Element) node, bd);  
           }  
       }  
   }  
   //解析<property>元素  
   public void parsePropertyElement(Element ele, BeanDefinition bd) {  
       //获取<property>元素的名字   
       String propertyName = ele.getAttribute(NAME_ATTRIBUTE);  
       if (!StringUtils.hasLength(propertyName)) {  
           error("Tag 'property' must have a 'name' attribute", ele);  
           return;  
       }  
       this.parseState.push(new PropertyEntry(propertyName));  
       try {  
           //如果一个Bean中已经有同名的property存在，则不进行解析，直接返回。  
           //即如果在同一个Bean中配置同名的property，则只有第一个起作用  
           if (bd.getPropertyValues().contains(propertyName)) {  
               error("Multiple 'property' definitions for property '" + propertyName + "'", ele);  
               return;  
           }  
           //解析获取property的值  
           Object val = parsePropertyValue(ele, bd, propertyName);  
           //根据property的名字和值创建property实例  
           PropertyValue pv = new PropertyValue(propertyName, val);  
           //解析<property>元素中的属性  
           parseMetaElements(ele, pv);  
           pv.setSource(extractSource(ele));  
           bd.getPropertyValues().addPropertyValue(pv);  
       }  
       finally {  
           this.parseState.pop();  
       }  
   }  
   //解析获取property值  
   public Object parsePropertyValue(Element ele, BeanDefinition bd, String propertyName) {  
       String elementName = (propertyName != null) ?  
                       "<property> element for property '" + propertyName + "'" :  
                       "<constructor-arg> element";  
       //获取<property>的所有子元素，只能是其中一种类型:ref,value,list等  
       NodeList nl = ele.getChildNodes();  
       Element subElement = null;  
       for (int i = 0; i < nl.getLength(); i++) {  
           Node node = nl.item(i);  
           //子元素不是description和meta属性  
           if (node instanceof Element && !nodeNameEquals(node, DESCRIPTION_ELEMENT) &&  
                   !nodeNameEquals(node, META_ELEMENT)) {  
               if (subElement != null) {  
                   error(elementName + " must not contain more than one sub-element", ele);  
               }  
               else {//当前<property>元素包含有子元素  
                   subElement = (Element) node;  
               }  
           }  
       }  
       //判断property的属性值是ref还是value，不允许既是ref又是value  
       boolean hasRefAttribute = ele.hasAttribute(REF_ATTRIBUTE);  
       boolean hasValueAttribute = ele.hasAttribute(VALUE_ATTRIBUTE);  
       if ((hasRefAttribute && hasValueAttribute) ||  
               ((hasRefAttribute || hasValueAttribute) && subElement != null)) {  
           error(elementName +  
                   " is only allowed to contain either 'ref' attribute OR 'value' attribute OR sub-element", ele);  
       }  
       //如果属性是ref，创建一个ref的数据对象RuntimeBeanReference，这个对象  
       //封装了ref信息  
       if (hasRefAttribute) {  
           String refName = ele.getAttribute(REF_ATTRIBUTE);  
           if (!StringUtils.hasText(refName)) {  
               error(elementName + " contains empty 'ref' attribute", ele);  
           }  
           //一个指向运行时所依赖对象的引用  
           RuntimeBeanReference ref = new RuntimeBeanReference(refName);  
           //设置这个ref的数据对象是被当前的property对象所引用  
           ref.setSource(extractSource(ele));  
           return ref;  
       }  
        //如果属性是value，创建一个value的数据对象TypedStringValue，这个对象  
       //封装了value信息  
       else if (hasValueAttribute) {  
           //一个持有String类型值的对象  
           TypedStringValue valueHolder = new TypedStringValue(ele.getAttribute(VALUE_ATTRIBUTE));  
           //设置这个value数据对象是被当前的property对象所引用  
           valueHolder.setSource(extractSource(ele));  
           return valueHolder;  
       }  
       //如果当前<property>元素还有子元素  
       else if (subElement != null) {  
           //解析<property>的子元素  
           return parsePropertySubElement(subElement, bd);  
       }  
       else {  
           //propery属性中既不是ref，也不是value属性，解析出错返回null        error(elementName + " must specify a ref or value", ele);  
           return null;  
       }  
    }
```
通过对上述源码的分析，我们可以了解在`Spring`配置文件中，`<Bean>`元素中`<property>`元素的相关配置是如何处理的：

- `ref`被封装为指向依赖对象一个引用。
- `value`配置都会封装成一个字符串类型的对象。
- `ref`和`value`都通过`解析的数据类型属性值.setSource(extractSource(ele));`方法将属性值/引用与所引用的属性关联起来。

在方法的最后对于`<property>`元素的子元素通过`parsePropertySubElement`方法解析，我们继续分析该方法的源码，了解其解析过程。

##### 3.2.4.7 BeanDefinitionParserDelegate解析<property>元素
在`BeanDefinitionParserDelegate`类中的`parsePropertySubElement`方法对`<property>`中的子元素解析:
```Java
//解析<property>元素中ref,value或者集合等子元素  
   public Object parsePropertySubElement(Element ele, BeanDefinition bd, String defaultValueType) {  
       //如果<property>没有使用Spring默认的命名空间，则使用用户自定义的规则解析//内嵌元素  
       if (!isDefaultNamespace(ele)) {  
           return parseNestedCustomElement(ele, bd);  
       }  
       //如果子元素是bean，则使用解析<Bean>元素的方法解析  
       else if (nodeNameEquals(ele, BEAN_ELEMENT)) {  
           BeanDefinitionHolder nestedBd = parseBeanDefinitionElement(ele, bd);  
           if (nestedBd != null) {  
               nestedBd = decorateBeanDefinitionIfRequired(ele, nestedBd, bd);  
           }  
           return nestedBd;  
       }  
       //如果子元素是ref，ref中只能有以下3个属性：bean、local、parent  
       else if (nodeNameEquals(ele, REF_ELEMENT)) {  
           //获取<property>元素中的bean属性值，引用其他解析的Bean的名称  
           //可以不再同一个Spring配置文件中，具体请参考Spring对ref的配置规则  
           String refName = ele.getAttribute(BEAN_REF_ATTRIBUTE);  
           boolean toParent = false;  
           if (!StringUtils.hasLength(refName)) {  
                //获取<property>元素中的local属性值，引用同一个Xml文件中配置  
                //的Bean的id，local和ref不同，local只能引用同一个配置文件中的Bean  
               refName = ele.getAttribute(LOCAL_REF_ATTRIBUTE);  
               if (!StringUtils.hasLength(refName)) {  
                   //获取<property>元素中parent属性值，引用父级容器中的Bean  
                   refName = ele.getAttribute(PARENT_REF_ATTRIBUTE);  
                   toParent = true;  
                   if (!StringUtils.hasLength(refName)) {  
                       error("'bean', 'local' or 'parent' is required for <ref> element", ele);  
                       return null;  
                   }  
               }  
           }  
           //没有配置ref的目标属性值  
           if (!StringUtils.hasText(refName)) {  
               error("<ref> element contains empty target attribute", ele);  
               return null;  
           }  
           //创建ref类型数据，指向被引用的对象  
           RuntimeBeanReference ref = new RuntimeBeanReference(refName, toParent);  
           //设置引用类型值是被当前子元素所引用  
           ref.setSource(extractSource(ele));  
           return ref;  
       }  
       //如果子元素是<idref>，使用解析ref元素的方法解析  
       else if (nodeNameEquals(ele, IDREF_ELEMENT)) {  
           return parseIdRefElement(ele);  
       }  
       //如果子元素是<value>，使用解析value元素的方法解析  
       else if (nodeNameEquals(ele, VALUE_ELEMENT)) {  
           return parseValueElement(ele, defaultValueType);  
       }  
       //如果子元素是null，为<property>设置一个封装null值的字符串数据  
       else if (nodeNameEquals(ele, NULL_ELEMENT)) {  
           TypedStringValue nullHolder = new TypedStringValue(null);  
           nullHolder.setSource(extractSource(ele));  
           return nullHolder;  
       }  
       //如果子元素是<array>，使用解析array集合子元素的方法解析  
       else if (nodeNameEquals(ele, ARRAY_ELEMENT)) {  
           return parseArrayElement(ele, bd);  
       }  
       //如果子元素是<list>，使用解析list集合子元素的方法解析  
       else if (nodeNameEquals(ele, LIST_ELEMENT)) {  
           return parseListElement(ele, bd);  
       }  
       //如果子元素是<set>，使用解析set集合子元素的方法解析  
       else if (nodeNameEquals(ele, SET_ELEMENT)) {  
           return parseSetElement(ele, bd);  
       }  
       //如果子元素是<map>，使用解析map集合子元素的方法解析  
       else if (nodeNameEquals(ele, MAP_ELEMENT)) {  
           return parseMapElement(ele, bd);  
       }  
       //如果子元素是<props>，使用解析props集合子元素的方法解析  
       else if (nodeNameEquals(ele, PROPS_ELEMENT)) {  
           return parsePropsElement(ele);  
       }  
       //既不是ref，又不是value，也不是集合，则子元素配置错误，返回null  
       else {  
           error("Unknown property sub-element: [" + ele.getNodeName() + "]", ele);  
           return null;  
       }  
    }
```
通过上述源码分析，我们明白了在`Spring`配置文件中，对`<property>`元素中配置的`Array`、`List`、`Set`、`Map`、`Prop`等各种集合子元素的都通过上述方法解析，生成对应的数据对象，比如`ManagedList`、`ManagedArray`、`ManagedSet`等，这些`Managed`类是`Spring`对象`BeanDefiniton`的数据封装，对集合数据类型的具体解析有各自的解析方法实现，解析方法的命名非常规范，一目了然，我们对`<list>`集合元素的解析方法进行源码分析，了解其实现过程。

##### 3.2.4.8 解析<list>子元素
```Java
//解析<list>集合子元素  
   public List parseListElement(Element collectionEle, BeanDefinition bd) {  
       //获取<list>元素中的value-type属性，即获取集合元素的数据类型  
       String defaultElementType = collectionEle.getAttribute(VALUE_TYPE_ATTRIBUTE);  
       //获取<list>集合元素中的所有子节点  
       NodeList nl = collectionEle.getChildNodes();  
       //Spring中将List封装为ManagedList  
       ManagedList<Object> target = new ManagedList<Object>(nl.getLength());  
       target.setSource(extractSource(collectionEle));  
       //设置集合目标数据类型  
       target.setElementTypeName(defaultElementType);  
       target.setMergeEnabled(parseMergeAttribute(collectionEle));  
       //具体的<list>元素解析  
       parseCollectionElements(nl, target, bd, defaultElementType);  
       return target;  
   }   
   //具体解析<list>集合元素，<array>、<list>和<set>都使用该方法解析  
   protected void parseCollectionElements(  
           NodeList elementNodes, Collection<Object> target, BeanDefinition bd, String defaultElementType) {  
       //遍历集合所有节点  
       for (int i = 0; i < elementNodes.getLength(); i++) {  
           Node node = elementNodes.item(i);  
           //节点不是description节点  
           if (node instanceof Element && !nodeNameEquals(node, DESCRIPTION_ELEMENT)) {  
               //将解析的元素加入集合中，递归调用下一个子元素  
               target.add(parsePropertySubElement((Element) node, bd, defaultElementType));  
           }  
       }  
    }
```

经过对`Spring Bean`定义资源文件转换的`Document`对象中的元素层层解析，`Spring IoC`现在已经将`XML`形式定义的`Bean`定义资源文件转换为`Spring IoC`所识别的数据结构——`BeanDefinition`，它是`Bean`定义资源文件中配置的`POJO`对象在`Spring IoC`容器中的映射，我们可以通过`AbstractBeanDefinition`为入口, 对`IoC`容器进行索引、查询和操作。

通过`Spring IoC`容器对`Bean`定义资源的解析后，`IoC`容器大致完成了管理`Bean`对象的准备工作，即初始化过程，但是最为重要的依赖注入还没有发生，现在在`IoC`容器中`BeanDefinition`存储的只是一些静态信息，接下来需要向容器注册`Bean`定义信息才能全部完成`IoC`容器的初始化过程.


#### 3.2.5 `DefaultListableBeanFactory`向`IoC`容器注册解析后的`BeanDefinition`
```Java
public class DefaultBeanDefinitionDocumentReader implements BeanDefinitionDocumentReader {
    protected void processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate) {
      BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);
      if (bdHolder != null) {
        bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);
        try {
          // Register the final decorated instance.
          BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());
        }
        catch (BeanDefinitionStoreException ex) {
          getReaderContext().error("Failed to register bean definition with name '" +
              bdHolder.getBeanName() + "'", ele, ex);
        }
        // Send registration event.
        getReaderContext().fireComponentRegistered(new BeanComponentDefinition(bdHolder));
      }
    }
}
```
在这里 `DefaultBeanDefinitionDocumentReader`调用了`BeanDefinitionReaderUtils.registerBeanDefinition`
```Java
public static void registerBeanDefinition(
    BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)
    throws BeanDefinitionStoreException {

  // Register bean definition under primary name.
  String beanName = definitionHolder.getBeanName();
  //向IoC容器注册BeanDefinition
  registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());

  // Register aliases for bean name, if any.
  String[] aliases = definitionHolder.getAliases();
  if (aliases != null) {
    for (String alias : aliases) {
      registry.registerAlias(beanName, alias);
    }
  }
}
```

##### 3.2.5.1 DefaultListableBeanFactory向IoC容器注册解析后的BeanDefinition：
`DefaultListableBeanFactory`中使用一个`HashMap`的集合对象存放`IoC`容器中注册解析的`BeanDefinition`，向`IoC`容器注册的主要源码如下：
```Java
public class DefaultListableBeanFactory extends AbstractAutowireCapableBeanFactory
		implements ConfigurableListableBeanFactory, BeanDefinitionRegistry, Serializable {
      /** Map of bean definition objects, keyed by bean name */
      private final Map<String, BeanDefinition> beanDefinitionMap =
          new ConcurrentHashMap<String, BeanDefinition>(256);

      public void registerBeanDefinition(String beanName, BeanDefinition beanDefinition)
      			throws BeanDefinitionStoreException {

      		Assert.hasText(beanName, "Bean name must not be empty");
      		Assert.notNull(beanDefinition, "BeanDefinition must not be null");

      		if (beanDefinition instanceof AbstractBeanDefinition) {
      			try {
      				((AbstractBeanDefinition) beanDefinition).validate();
      			}
      			catch (BeanDefinitionValidationException ex) {
      				throw new BeanDefinitionStoreException(beanDefinition.getResourceDescription(), beanName,
      						"Validation of bean definition failed", ex);
      			}
      		}

      		BeanDefinition oldBeanDefinition;

      		oldBeanDefinition = this.beanDefinitionMap.get(beanName);
      		if (oldBeanDefinition != null) {
      			if (!isAllowBeanDefinitionOverriding()) {
      				throw new BeanDefinitionStoreException(beanDefinition.getResourceDescription(), beanName,
      						"Cannot register bean definition [" + beanDefinition + "] for bean '" + beanName +
      						"': There is already [" + oldBeanDefinition + "] bound.");
      			}
      			else if (oldBeanDefinition.getRole() < beanDefinition.getRole()) {
      				// e.g. was ROLE_APPLICATION, now overriding with ROLE_SUPPORT or ROLE_INFRASTRUCTURE
      				if (this.logger.isWarnEnabled()) {
      					this.logger.warn("Overriding user-defined bean definition for bean '" + beanName +
      							"' with a framework-generated bean definition: replacing [" +
      							oldBeanDefinition + "] with [" + beanDefinition + "]");
      				}
      			}
      			else if (!beanDefinition.equals(oldBeanDefinition)) {
      				if (this.logger.isInfoEnabled()) {
      					this.logger.info("Overriding bean definition for bean '" + beanName +
      							"' with a different definition: replacing [" + oldBeanDefinition +
      							"] with [" + beanDefinition + "]");
      				}
      			}
      			else {
      				if (this.logger.isDebugEnabled()) {
      					this.logger.debug("Overriding bean definition for bean '" + beanName +
      							"' with an equivalent definition: replacing [" + oldBeanDefinition +
      							"] with [" + beanDefinition + "]");
      				}
      			}
      			this.beanDefinitionMap.put(beanName, beanDefinition);
      		}
      		else {
      			if (hasBeanCreationStarted()) {
      				// Cannot modify startup-time collection elements anymore (for stable iteration)
              //注册的过程中需要线程同步，以保证数据的一致性
      				synchronized (this.beanDefinitionMap) {
      					this.beanDefinitionMap.put(beanName, beanDefinition);
      					List<String> updatedDefinitions = new ArrayList<String>(this.beanDefinitionNames.size() + 1);
      					updatedDefinitions.addAll(this.beanDefinitionNames);
      					updatedDefinitions.add(beanName);
      					this.beanDefinitionNames = updatedDefinitions;
      					if (this.manualSingletonNames.contains(beanName)) {
      						Set<String> updatedSingletons = new LinkedHashSet<String>(this.manualSingletonNames);
      						updatedSingletons.remove(beanName);
      						this.manualSingletonNames = updatedSingletons;
      					}
      				}
      			}
      			else {
      				// Still in startup registration phase
      				this.beanDefinitionMap.put(beanName, beanDefinition);
      				this.beanDefinitionNames.add(beanName);
      				this.manualSingletonNames.remove(beanName);
      			}
      			this.frozenBeanDefinitionNames = null;
      		}

      		if (oldBeanDefinition != null || containsSingleton(beanName)) {
      			resetBeanDefinition(beanName);
      		}
      }
}

```

至此，`Bean`定义资源文件中配置的`Bean`被解析过后，已经注册到`IoC`容器中，被容器管理起来，真正完成了`IoC`容器初始化所做的全部工作。现  在`IoC`容器中已经建立了整个`Bean`的配置信息，这些`BeanDefinition`信息已经可以使用，并且可以被检索，`IoC`容器的作用就是对这些注册的`Bean`定义信息进行处理和维护。这些的注册的`Bean`定义信息是`IoC`容器控制反转的基础，正是有了这些注册的数据，容器才可以进行依赖注入。

### 3.3 总结IOC容器的基本步骤

1. 初始化的入口在容器实现中的 `refresh()`调用来完成.
2. 对` bean` 定义载入`IOC`容器使用的方法是`loadBeanDefinition`,其中的大致过程如下：
- 为容器设置`Bean`资源加载器。`AbstractApplicationContext`构造方法中调用`PathMatchingResourcePatternResolver`的构造方法创建`Spring`资源加载器。
- 设置`Bean`定义资源文件的定位路径。
- `refresh`函数载入`Bean`定义过程。
  - `obtainFreshBeanFactory()`方法 刷新容器.
  - `BeanDefinition`读取`Bean`定义资源。读取资源转换为`Document`。`DocumentLoader`解析`xml`文件。`XmlBeanDefinitionReader`解析载入的`Bean`定义资源文件。`BeanDefinitionParserDelegate`解析`Bean`定义资源文件中的`<Bean>`元素。`DefaultListableBeanFactory`向`IoC`容器注册解析后的`BeanDefinition`。`DefaultListableBeanFactory`向`IoC`容器注册解析后的`BeanDefinition`。

- 通过`ResourceLoader`来完成资源文件位置的定位，`DefaultResourceLoader`是默认的实现，同时上下文本身就给出了 `ResourceLoader`的实现，可以从类路径，文件系统, `URL`等方式来定为资源位置。如果是`XmlBeanFactory`作为`IOC`容器，那么需要为它指定`bean`定义的资源，也就是说`bean`定义文件时通过抽象成`Resource`来被`IOC`容器处理的，容器通过`BeanDefinitionReader`来完成定义信息的解析和 `Bean`信息的注册,往往使用的是`XmlBeanDefinitionReader`来解析`bean`的`xml`定义文件 - 实际的处理过程是委托给 `BeanDefinitionParserDelegate`来完成的，从而得到`bean`的定义信息，这些信息在`Spring`中使用`BeanDefinition`对象来表示 - 这个名字可以让我们想到`loadBeanDefinition`,`RegisterBeanDefinition`这些相关的方法 - 他们都是为处理`BeanDefinitin`服务的， 容器解析得到`BeanDefinitionIoC`以后，需要把它在`IOC`容器中注册, 这由`IOC`实现`BeanDefinitionRegistry`接口来实现。注册过程就是在`IOC`容器内部维护的一个`HashMap`来保存得到的`BeanDefinition`的过程。这个`HashMap`是`IoC`容器持有`bean`信息的场所，以后对 `bean`的操作都是围绕这个`HashMap`来实现的。

3. 然后我们就可以通过`BeanFactory`和`ApplicationContext`来享受到`Spring IOC`的服务了,在使用`IOC`容器的时候，我们注意到除了少量粘合代码，绝大多数以正确`IoC`风格编写的应用程序代码完全不用关心如何到达工厂，因为容器将把这些对象与容器管理的其他对象钩在一起。基本的策略是把工厂放到已知的地方，最好是放在对预期使用的上下文有意义的地方，以及代码将实际需要访问工厂的地方。`Spring`本身提供了对声明式载入`web`应用程序用法的应用程序上下文,并将其存储在`ServletContext`中的框架实现。

> `Beanfactory`和 `Factory bean`，其中`BeanFactory`指的是`IOC`容器的编程抽象，比如 `ApplicationContext`， `XmlBeanFactory` 等，这些都是`IOC`容器的具体表现，需要使用什么样的容器由客户决定,但`Spring`为我们提供了丰富的选择。 `FactoryBean`只是一个可以在`IOC`而容器中被管理的一个`bean`,是对各种处理过程和资源使用的抽象,`Factory bean`在需要时产生另一个对象，而不返回`FactoryBean`本身,我们可以把它看成是一个抽象工厂，对它的调用返回的是工厂生产的产品。所有的`Factory bean`都实现特殊的`org.springframework.beans.factory.FactoryBean`接口，当使用容器中`factory bean`的时候，该容器不会返回 `factory bean`本身,而是返回其生成的对象。`Spring`包括了大部分的通用资源和服务访问抽象的 `Factory bean`的实现，其中包括:对 `JNDI`查询的处理，对代理对象的处理，对事务性代理的处理，对`RMI`代理的处理等，这些我们都可以看成是具体的工厂,看成是`SPRING`为我们建立好的工厂。也就是说 `Spring`通过使用抽象工厂模式为我们准备了一系列工厂来生产一些特定的对象,免除我们手工重复的工作，我们要使用时只需要在`IOC`容器里配置好就能很方便的使用了。















[1]:https://images0.cnblogs.com/blog/400827/201409/172219470349285.x-png
[2]:https://s26.postimg.org/5pisndljd/spring_beandefinition.png
[3]:https://s26.postimg.org/s2qjah4k9/classpathxmlapplicaitoncontext.png
[4]:https://s26.postimg.org/vmch0e9vt/xmlbean_Factory.png
[5]:https://s26.postimg.org/d0s358tdl/Abstract_Bean_Definition_Reader.png
